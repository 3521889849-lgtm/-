# 链路追踪（Distributed Tracing）技术总结

> 本文档基于项目 `piaowu` 的链路追踪实现，总结核心概念、架构设计和最佳实践。

---

## 目录

- [一、概述](#一概述)
- [二、核心概念](#二核心概念)
- [三、架构设计](#三架构设计)
- [四、核心实现](#四核心实现)
- [五、中间件集成](#五中间件集成)
- [六、Jaeger 导出器](#六jaeger-导出器)
- [七、敏感数据脱敏](#七敏感数据脱敏)
- [八、最佳实践](#八最佳实践)
- [九、常见问题](#九常见问题)
- [十、目录结构](#十目录结构)

---

## 一、概述

链路追踪是分布式系统中用于**追踪请求在多个服务间流转**的技术，帮助开发者：

- 理解系统行为和服务依赖
- 定位性能瓶颈
- 快速排查问题
- 可视化调用链路

本项目采用 **自定义实现 + Jaeger 可视化** 的方案，核心组件位于 `pkg/trace/` 目录。

---

## 二、核心概念

### 2.1 Trace、Span、Context

| 概念 | 说明 | 生成规则 |
|------|------|----------|
| **TraceID** | 整条链路的唯一标识，贯穿所有服务 | 32字符十六进制（16字节随机） |
| **SpanID** | 单个操作的唯一标识 | 16字符十六进制（8字节随机） |
| **ParentSpanID** | 父操作的 SpanID，用于构建调用树 | 从上游继承 |

### 2.2 Span 类型（SpanKind）

```go
const (
    SpanKindInternal  // 内部操作
    SpanKindServer    // 服务端接收请求
    SpanKindClient    // 客户端发起请求
    SpanKindProducer  // 消息生产者
    SpanKindConsumer  // 消息消费者
)
```

### 2.3 Span 状态

```go
const (
    SpanStatusUnset  // 未设置
    SpanStatusOK     // 成功
    SpanStatusError  // 错误
)
```

### 2.4 Span 结构

```go
type Span struct {
    TraceID      string            // 链路唯一标识
    SpanID       string            // 当前 Span 唯一标识
    ParentSpanID string            // 父 Span ID
    Name         string            // Span 名称
    Kind         SpanKind          // Span 类型
    Service      string            // 服务名称
    StartTime    time.Time         // 开始时间
    EndTime      time.Time         // 结束时间
    Duration     time.Duration     // 持续时间
    Status       SpanStatus        // 状态
    Attributes   map[string]string // 属性（已脱敏）
    Events       []SpanEvent       // 事件列表
    Error        error             // 错误信息
}
```

---

## 三、架构设计

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        请求流向                                  │
│  Client → Gateway → RPC Service → DB/Redis/MQ → Response        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     链路追踪层次                                 │
├─────────────────────────────────────────────────────────────────┤
│  Layer 1: HTTP Server Span (Gateway)                            │
│     └── Layer 2: RPC Client Span (Gateway → Service)            │
│           └── Layer 3: RPC Server Span (Service)                │
│                 ├── Layer 4: DB Span (MySQL)                    │
│                 ├── Layer 4: Redis Span                         │
│                 └── Layer 4: MQ Span                            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Jaeger Exporter                              │
│     批量异步导出 → http://localhost:4318/v1/traces (OTLP HTTP)  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Context 传播流程

```
┌──────────┐    X-Trace-ID    ┌──────────┐    metainfo    ┌──────────┐
│  Client  │ ───────────────→ │ Gateway  │ ─────────────→ │ Service  │
└──────────┘    X-Span-ID     └──────────┘    trace-id    └──────────┘
                                   │              │              │
                              ctx.Value      ctx.Value      ctx.Value
                              (TraceID)      (TraceID)      (TraceID)
```

---

## 四、核心实现

### 4.1 Span 创建与结束

```go
// 创建 Span
ctx, span := trace.StartSpan(ctx, "操作名称",
    trace.WithSpanKind(trace.SpanKindServer),
    trace.WithService("service-name"),
)

// 设置属性
span.SetAttribute("key", "value")
span.SetBusinessAttrs(userID, orderID)  // 自动脱敏

// 记录错误
if err != nil {
    span.SetError(err)
}

// 添加事件
span.AddEvent("event_name", map[string]string{"key": "value"})

// 结束 Span（自动计算耗时、导出到 Jaeger）
span.End()
```

### 4.2 便捷函数

| 函数 | 用途 | SpanKind |
|------|------|----------|
| `StartServerSpan(ctx, service, method)` | 服务端接收请求 | Server |
| `StartClientSpan(ctx, service, method)` | 客户端发起请求 | Client |
| `StartDBSpan(ctx, operation, table)` | 数据库操作 | Client |
| `StartRedisSpan(ctx, operation, key)` | Redis 操作 | Client |
| `StartHTTPSpan(ctx, method, path)` | HTTP 请求 | Client |

### 4.3 Context 操作

```go
// 注入追踪信息
ctx = trace.WithTraceID(ctx, traceID)
ctx = trace.WithSpanID(ctx, spanID)
ctx = trace.WithParentSpanID(ctx, parentSpanID)

// 提取追踪信息
traceID := trace.GetTraceID(ctx)
spanID := trace.GetSpanID(ctx)
parentSpanID := trace.GetParentSpanID(ctx)
```

### 4.4 ID 生成

```go
// 生成 TraceID（32字符）
traceID := trace.NewTraceID()  // e.g., "a1b2c3d4e5f6789012345678abcdef01"

// 生成 SpanID（16字符）
spanID := trace.NewSpanID()    // e.g., "1234567890abcdef"
```

---

## 五、中间件集成

### 5.1 Gateway HTTP 中间件

**文件**: `gateway/middleware/trace.go`

```go
func TraceMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 从 Header 提取/生成 TraceID
        traceID := r.Header.Get("X-Trace-ID")
        if traceID == "" {
            traceID = trace.NewTraceID()
        }
        
        // 2. 创建 Server Span
        ctx, span := trace.StartSpan(ctx, spanName,
            trace.WithSpanKind(trace.SpanKindServer),
            trace.WithService("gateway"),
        )
        
        // 3. 设置 HTTP 属性
        span.SetAttribute("http.method", r.Method)
        span.SetAttribute("http.path", r.URL.Path)
        
        // 4. 响应 Header 返回追踪信息
        w.Header().Set("X-Trace-ID", traceID)
        w.Header().Set("X-Span-ID", span.SpanID)
        
        // 5. 执行下游处理
        next.ServeHTTP(w, r.WithContext(ctx))
        
        // 6. 结束 Span
        span.End()
    })
}
```

**HTTP Header 常量**:

| Header | 说明 |
|--------|------|
| `X-Trace-ID` | 链路追踪ID |
| `X-Span-ID` | 当前 Span ID |
| `X-Parent-Span-ID` | 父 Span ID |

### 5.2 Kitex RPC 中间件

**文件**: `pkg/trace/kitex.go`

#### Server 端中间件

```go
func ServerTraceMiddleware(serviceName string) endpoint.Middleware {
    return func(next endpoint.Endpoint) endpoint.Endpoint {
        return func(ctx context.Context, req, resp interface{}) error {
            // 1. 从上游提取 TraceID
            traceID := extractMetaValue(ctx, MetaKeyTraceID)
            if traceID == "" {
                traceID = NewTraceID()
            }
            
            // 2. 创建 Server Span
            ctx, span := StartSpan(ctx, methodName,
                WithSpanKind(SpanKindServer),
                WithService(serviceName),
            )
            
            // 3. 执行业务逻辑
            defer span.End()
            return next(ctx, req, resp)
        }
    }
}
```

#### Client 端中间件

```go
func ClientTraceMiddleware(serviceName string) endpoint.Middleware {
    return func(next endpoint.Endpoint) endpoint.Endpoint {
        return func(ctx context.Context, req, resp interface{}) error {
            // 1. 创建 Client Span（继承 TraceID）
            ctx, span := StartSpan(ctx, methodName,
                WithSpanKind(SpanKindClient),
                WithService(targetService),
            )
            
            // 2. 执行 RPC 调用
            defer span.End()
            return next(ctx, req, resp)
        }
    }
}
```

> **重要**: RPC 服务端**必须**实现 `ServerTraceMiddleware`，否则链路会断裂！

### 5.3 GORM 数据库插件

**文件**: `pkg/trace/gorm.go`

```go
// 注册插件
db.Use(trace.NewGormTracePlugin("service-name"))
```

**自动追踪的操作**:

| 操作 | SQL 类型 |
|------|----------|
| Create | INSERT |
| Query | SELECT |
| Update | UPDATE |
| Delete | DELETE |
| Raw/Row | 自定义 |

**记录的属性**:

```go
span.SetAttribute("db.system", "mysql")
span.SetAttribute("db.operation", operation)    // INSERT/SELECT/UPDATE/DELETE
span.SetAttribute("db.table", table)            // 表名
span.SetAttribute("db.statement", sql)          // SQL（截断至500字符）
span.SetAttribute("db.rows_affected", rows)     // 影响行数
```

#### 事务追踪

```go
err := trace.WithTxTrace(ctx, db, func(tx *gorm.DB) error {
    // 事务内的操作
    return tx.Create(&record).Error
})
```

### 5.4 Redis 追踪

**文件**: `pkg/trace/redis.go`

#### 方式1：使用追踪器

```go
tracer := trace.NewRedisTracer("service-name")

result, err := tracer.TraceCommand(ctx, "GET", key, func() (interface{}, error) {
    return rdb.Get(ctx, key).Result()
})
```

#### 方式2：使用便捷函数

```go
// GET
value, err := trace.TraceRedisGet(ctx, key, func() (string, error) {
    return rdb.Get(ctx, key).Result()
})

// SET
err := trace.TraceRedisSet(ctx, key, func() error {
    return rdb.Set(ctx, key, value, ttl).Err()
})

// DEL
err := trace.TraceRedisDel(ctx, []string{key}, func() error {
    return rdb.Del(ctx, key).Err()
})

// HGET
value, err := trace.TraceRedisHGet(ctx, key, field, func() (string, error) {
    return rdb.HGet(ctx, key, field).Result()
})

// EXPIRE
err := trace.TraceRedisExpire(ctx, key, ttl, func() error {
    return rdb.Expire(ctx, key, ttl).Err()
})
```

### 5.5 消息队列追踪

```go
tracer := trace.NewMQTracer("service-name")

// 发布消息
err := tracer.TracePublish(ctx, topic, func() error {
    return mq.Publish(topic, message)
})

// 消费消息
err := tracer.TraceConsume(ctx, topic, func(ctx context.Context) error {
    return handleMessage(ctx, message)
})
```

---

## 六、Jaeger 导出器

### 6.1 配置结构

```go
type JaegerConfig struct {
    Endpoint      string        // Jaeger 端点地址
    ServiceName   string        // 服务名称
    Enabled       bool          // 是否启用
    SampleRate    float64       // 采样率 (0.0 ~ 1.0)
    BatchSize     int           // 批量发送大小
    FlushInterval time.Duration // 刷新间隔
}
```

### 6.2 配置示例

```yaml
tracing:
  endpoint: "http://localhost:4318/v1/traces"
  service_name: "customer-service"
  enabled: true
  sample_rate: 0.1
  batch_size: 100
  flush_interval: 5s
```

> **重要**: 使用 OTLP HTTP 端点 **4318**，而非旧版 Jaeger Collector 14268！

### 6.3 初始化

```go
// 初始化
trace.InitJaeger(&trace.JaegerConfig{
    Endpoint:    "http://localhost:4318/v1/traces",
    ServiceName: "customer-service",
    Enabled:     true,
    SampleRate:  0.1,
})

// 关闭（程序退出时调用）
defer trace.ShutdownJaeger()
```

### 6.4 采样策略

采用**一致性采样**，基于 TraceID 的 hash 值：

```go
func (e *JaegerExporter) Export(span *Span) {
    // 一致性采样：同一链路的所有 Span 采样结果一致
    hash := hashTraceID(span.TraceID)
    if float64(hash%100)/100.0 > e.config.SampleRate {
        return  // 跳过采样
    }
    // ... 导出逻辑
}
```

**优点**: 同一条链路的所有 Span 要么全部采样，要么全部不采样，避免链路残缺。

### 6.5 批量异步导出

```go
// 后台协程定时刷新
func (e *JaegerExporter) flushLoop() {
    ticker := time.NewTicker(e.config.FlushInterval)
    for {
        select {
        case <-ticker.C:
            e.flush()
        case <-e.stopCh:
            e.flush()  // 最后一次刷新
            return
        }
    }
}

// 达到批量大小时立即刷新
if len(e.spans) >= e.config.BatchSize {
    go e.flush()
}
```

---

## 七、敏感数据脱敏

### 7.1 脱敏规则

| 字段类型 | 原始值 | 脱敏后 | 函数 |
|----------|--------|--------|------|
| UserID | `12345678` | `1234****` | `MaskUserID()` |
| OrderID | `ORD20240101123456` | `ORD2024****3456` | `MaskOrderID()` |
| Redis Key | `user:12345678` | `user:1234****` | `maskRedisKey()` |
| URL | `http://api.com/users?token=xxx...` | 截断至100字符 | `maskURL()` |
| Query String | `token=xxx&user=123...` | 截断至50字符 | `maskQueryString()` |

### 7.2 使用方式

```go
// 自动脱敏
span.SetBusinessAttrs(userID, orderID)

// 手动脱敏
maskedUserID := trace.MaskUserID("12345678")      // "1234****"
maskedOrderID := trace.MaskOrderID("ORD20240101") // "ORD2024****0101"
```

---

## 八、最佳实践

### 8.1 关键业务节点补充 Child Span

在以下节点创建 child span，以完善链路追踪细节：

- 数据库操作（GORM 插件自动处理）
- Redis 操作
- 消息队列（发布/消费）
- 外部 HTTP 调用
- 关键业务逻辑

### 8.2 错误处理

```go
result, err := doSomething()
if err != nil {
    span.SetError(err)  // 自动设置 SpanStatusError
    return err
}
```

### 8.3 慢操作告警

超过 200ms 的操作自动记录为 WARN 级别日志：

```go
func (s *Span) log() {
    if s.Duration > 200*time.Millisecond {
        logger.Warn("Span End (slow)", fields...)
    }
}
```

### 8.4 日志关联

所有日志应携带 TraceID，便于问题排查：

```go
logger.InfoWithTrace(ctx, "处理请求", zap.String("key", "value"))
logger.ErrorWithTrace(ctx, "处理失败", zap.Error(err))
```

### 8.5 Context 传递

确保 Context 在整个调用链中正确传递：

```go
// GORM
db.WithContext(ctx).Find(&users)

// Redis
rdb.Get(ctx, key)

// HTTP Client
req = req.WithContext(ctx)
```

---

## 九、常见问题

### 9.1 问题排查表

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 链路断裂 | RPC 服务端未添加追踪中间件 | 添加 `ServerTraceMiddleware` |
| Jaeger 无数据 | 端点配置错误 | 使用 4318 端口（OTLP HTTP） |
| 采样不生效 | 采样率配置问题 | 检查 `sample_rate` 范围 0.0~1.0 |
| Context 丢失 | 未正确传递 ctx | 确保 `db.WithContext(ctx)` |
| Span 未结束 | 忘记调用 `span.End()` | 使用 `defer span.End()` |
| 属性丢失 | 并发写入冲突 | Span 内部已有 mutex 保护 |

### 9.2 端口说明

| 端口 | 协议 | 用途 |
|------|------|------|
| 4317 | gRPC | OTLP gRPC 端点 |
| **4318** | HTTP | **OTLP HTTP 端点（推荐）** |
| 14268 | HTTP | Jaeger Collector（旧版） |
| 16686 | HTTP | Jaeger UI |

---

## 十、目录结构

```
pkg/trace/
├── span.go       # Span 核心实现、Context 操作、ID 生成
├── exporter.go   # Jaeger 导出器（批量异步、采样策略）
├── kitex.go      # Kitex RPC 中间件（Server/Client）
├── http.go       # HTTP Server/Client 追踪
├── gorm.go       # GORM 数据库追踪插件
└── redis.go      # Redis/MQ/HTTP Client 追踪

gateway/middleware/
└── trace.go      # Gateway HTTP 追踪中间件

service/customer/dal/plugin/
└── trace.go      # 服务层数据库追踪插件
```

---

## 附录：快速参考

### Span 创建速查

```go
// HTTP Server
ctx, span := trace.StartSpan(ctx, "GET /api/users", trace.WithSpanKind(trace.SpanKindServer))

// RPC Client
ctx, span := trace.StartClientSpan(ctx, "customer-service", "GetUser")

// 数据库
ctx, span := trace.StartDBSpan(ctx, "SELECT", "users")

// Redis
ctx, span := trace.StartRedisSpan(ctx, "GET", "user:123")

// HTTP Client
ctx, span := trace.StartHTTPSpan(ctx, "POST", "/external/api")
```

### 属性设置速查

```go
span.SetAttribute("key", "value")           // 单个属性
span.SetAttributes(map[string]string{...})  // 批量属性
span.SetBusinessAttrs(userID, orderID)      // 业务属性（自动脱敏）
span.SetHTTPAttrs(method, path, statusCode) // HTTP 属性
span.SetRPCAttrs(service, method)           // RPC 属性
span.SetDBAttrs(operation, table, rows)     // 数据库属性
```

---

> **文档版本**: v1.0  
> **更新时间**: 2026-01-21  
> **相关技术**: Go, Kitex, GORM, OpenTelemetry, Jaeger
